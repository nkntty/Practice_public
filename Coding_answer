//Question5//
// 単一オブジェクトの場合
int* ptr = new int(42);        // メモリ確保
delete ptr;                    // メモリ解放
ptr = nullptr;                // 安全のためnullポインタに

// 配列の場合
int* arr = new int[100];      // 配列のメモリ確保
delete[] arr;                 // 配列のメモリ解放
arr = nullptr;               // 安全のためnullポインタに


//Question6//
(ptr + 1)->callMe();



//Question7// 

Stack<T>& operator-() {
    std::stack<T> temp;
    while (!stk.empty()) {
        temp.push(stk.top());
        stk.pop();
    }
    stk.swap(temp); // replace with reversed.   stk=temp; is fine too. BUT, stk.swap(temp)	O(1)	Fast pointer swap, no element copies

    return *this;   // return reference to self
}



Stack<T> operator-() const {
    Stack<T> reversed;
    std::stack<T> temp = stk; // copy of the member
    while (!temp.empty()) {
        reversed.stk.push(temp.top()); 
        temp.pop();
    }
    return reversed; // <-- returning the whole Stack<T> object
}

✅ Summary:

.count(key) → simplest way to check if key exists (returns 0 or 1 in sets/maps)

.find(key) → gives iterator to the key (useful if you want to read or modify the value)
#include <algorithm>
#include <vector>

std::vector<int> v = {1,2,3,4};

auto it = std::find(v.begin(), v.end(), 3); // std::find from <algorithm>
if (it != v.end()) {
    // found 3
}




Alright — if we assume your stack class from the webinar is something like:

template <typename T>
class Stack {
public:
    void push(const T& value);
    T pop();
    bool empty() const;
    // other member functions...
private:
    std::vector<T> elements; // or some container holding the stack data
};


You can overload the unary minus (operator-) as a member function to return a reversed stack like this:

template <typename T>
Stack<T> Stack<T>::operator-() const {
    Stack<T> reversed;
    for (auto it = elements.rbegin(); it != elements.rend(); ++it) {
        reversed.push(*it);
    }
    return reversed;
}







How this works:

operator-() is const because reversing doesn’t modify the original stack.

We create a new Stack<T> called reversed.

We iterate over elements in reverse order (using rbegin()/rend()).

We push each element into reversed.

Return the reversed stack.

If your original webinar stack didn’t use std::vector but instead stored elements differently (like a linked list or manual array), the core idea is the same: iterate from top to bottom and push into a new stack.

Do you want me to also show a non-member operator- version that works even if you can’t modify the stack class? That’s sometimes cleaner for symmetry.





Yeah, I see what you mean — your current code has a couple of problems:

Signature – You wrote

Stack<T> operator-(const Stack<T>& other)





That’s a binary minus operator (takes a parameter) instead of the unary one (operator-() with no parameters).
The “negation” operator you described should be unary.

Modifying the other stack – You’re popping from other, which is const in your function signature. This is not allowed, and even if it compiled (by removing const), it would be bad practice because you’d destroy the passed stack.

Return value – You’re doing return *this; but this is a free function (not a member), so *this isn’t defined here unless you wrote it as a member method.

Logic bug – for (!other.stk.empty()) isn’t valid syntax for a loop condition — that’s just a boolean expression, not a loop structure.

Here’s the correct unary member overload that returns a reversed stack without mutating the original:

template <typename T>
class Stack {
public:
    Stack<T> operator-() const {
        Stack<T> reversed;
        std::stack<T> temp = stk; // make a copy so we can pop safely
        while (!temp.empty()) {
            reversed.stk.push(temp.top());
            temp.pop();
        }
        return reversed;
    }

private:
    std::stack<T> stk; // your underlying storage
};

Why this works:

No parameters → unary -.

const → we guarantee the original isn’t modified.

We copy stk into temp so we can pop elements without touching the original.

We push them into reversed to get the reverse order.

If your intention was to write it outside the class (non-member), it would look like this:

template <typename T>
Stack<T> operator-(const Stack<T>& s) {
    Stack<T> reversed;
    std::stack<T> temp = s.stk; // copy
    while (!temp.empty()) {
        reversed.stk.push(temp.top());
        temp.pop();
    }
    return reversed;
}





//Question8//
Definitions
"UNIQUE" element usually means occurs exactly once in the vector.

Duplicate element is anything that occurs more than once.


#include <vector>
#include <unordered_set>

int countUnique(const std::vector<int>& vec) {
    std::unordered_set<int> seen;
    std::unordered_set<int> duplicates;

    for (const int& x : vec) {
        if (seen.count(x)) {
            duplicates.insert(x);  // already seen, mark as duplicate
        } else {
            seen.insert(x);        // first time seeing x
        }
    }

    return seen.size() - duplicates.size(); // remove duplicates
}

別解


#include <vector>
#include <unordered_map>

int countUnique(const std::vector<int>& vec) {
    std::unordered_map<int, int> counts;

    // Count occurrences of each element
    for (int x : vec) {
        counts[x]++;
    }

    // Count how many elements appear exactly once
    int uniqueCount = 0;
    for (auto& [key, val] : counts) {
        if (val == 1) uniqueCount++;
    }

    return uniqueCount;
}





//Question9//
#include <iostream>
#include <fstream>
#include <string>

int main() {
    std::string filename;
    std::cout << "Enter the file name: ";
    std::cin >> filename;

    std::ifstream file(filename);
    if (!file) {
        std::cerr << "Error: Could not open the file." << std::endl;
        return 1;
    }

    std::string content;
    std::string line;
    while (std::getline(file, line)) {
        content += line + "\n";
    }
    file.close();

    int count = 0;
    for (size_t i = 0; i + 2 < content.size(); ++i) {
        if (content[i] == '.' && content[i+1] == '.' && content[i+2] == '.') {
            count++;
            i += 2; // move ahead to avoid overlapping counts
        }
    }

    std::cout << "Number of ellipses in the file: " << count << std::endl;
    return 0;
}











//Question10//
int height(Node* root){
    if(!root){return 0;}
     int leftHeight=height(root->left);
     int rightHeight=height(root->right);
    return 1+max(leftHeight, rightHeight);
  }

bool Equal(Node* root){
    if(!root) return true;

    // recursively check left and right subtrees
    if(!Equal(root->left) || !Equal(root->right))
        return false;

    // check current node
    return root->val == height(root);
}




別解
#include <iostream>
#include <algorithm> // for std::max
using namespace std;

struct Node {
    int val;
    Node* left;
    Node* right;

    Node(int value) : val(value), left(nullptr), right(nullptr) {}
};

class BinaryTree {
public:
    Node* root;

    BinaryTree() : root(nullptr) {}

    // Public function
    bool is_height_tree() {
        bool isValid = true;
        checkHeightTree(root, isValid);
        return isValid;
    }

private:
    // Helper function: returns height and validates node values
    int checkHeightTree(Node* node, bool& isValid) {
        if (!node) return 0;

        int leftHeight = checkHeightTree(node->left, isValid);
        int rightHeight = checkHeightTree(node->right, isValid);

        int currentHeight = 1 + max(leftHeight, rightHeight);

        if (node->val != currentHeight) {
            isValid = false;
        }

        return currentHeight;
    }
};

int main() {
    // Example: construct a tree
    BinaryTree tree;
    tree.root = new Node(3);
    tree.root->left = new Node(2);
    tree.root->right = new Node(1);
    tree.root->left->left = new Node(1);

    cout << (tree.is_height_tree() ? "True" : "False") << endl;

    return 0;
}





